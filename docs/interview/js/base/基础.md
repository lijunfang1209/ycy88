# js 基础面试题目

#### 闭包

表现形式是函数里面返回方法
作用：

- 1. 私有作用域，vue 的 data 就是一个闭包的设计
- 2. 延长变量的生命周期，防抖的列子。
- 3. 内外方法沟通的桥梁

缺点：变量不能回收，内存泄漏，导致栈溢出，慎用、少用闭包。

#### 原型和原型链

参考地址:https://www.cnblogs.com/echolun/p/12321869.html

##### 1、什么是原型和原型链，原型链的顶端是什么?

函数才有原型，所有的数据都是有原型链的，构造函数是通过原型和原型链去继承的，原型就是一个包含诸多属性和方法的对象，new 一个构造函数实列的时候，访问构造函数的属性和方法的时候，会顺着 \_\_proto\_\_ 这个属性去查找属性和方法，这个查找的过程就是原型链。
原型链的顶端是 null
如何去查找：一层一层往上去查找，当访问构造函数的方法和属性的时候，首先要去查找构造函数本身有没有，然后再去查找她的原型上是否有，一级一级的往上找，直到找到原型的顶端的没有找到就返回 undefined。

##### 2、原型链和作用域链的区别？

原型链是查找构造函数的属性和方法所形成的，作用域链是在可访问的作用域内去查找变量是否存在的这个过程就是作用域链，一般表现就是闭包，内部函数访问外部函数的变量。
原型链的顶端是 null，作用域的顶端是全局变量，属性和方法不存的时候返回的是 undefined，作用域查找不存的时候会报错，变量未申明。

##### 3、构造函数和普通函数有什么区别？

本质是没有区别的，普通函数可以作为构造函数使用，构造函数可以作为普通函数使用。只是调用的方式不一样，构造函数调用是通过 new 关键字，普通函数是直接调用，es6 class 定义的函数，就只能 new 调用，普通调用的话， 会直接报错。

##### 4、能否判断当前函数是普通调用还是 new 调用？

通过 this 指向来判断，普通函数调用，this === window，但是 new 构造函数调用的时候，this 指向是构造函数创建的实列所以 this.constructor === 构造函数本身，代码如下:

```js
//判断是普通调用还是构造函数调用
const fn = function () {
  if (this === window) {
    console.log("普通函数调用");
  } else if (this.constructor === "fn") {
    console.log("new构造函数调用");
  }
};

fn(); //普通函数调用
new fn(); //new构造函数调用
```

##### 5、 prototype 与\_\_proto\_\_是什么?

prototype 是原型对象，\_\_proto\_\_是访问器属性，实列是通过\_\_proto\_\_去访问原型上的方法和属性

```js
function Fn() {
  this.a = 111;
  this.b = "bbb";
}
let fn1 = new Fn();
fn1.__proto__ === Fn.prototype;
```

##### 6、怎么判断对象是否包含某条属性？

通过 in 去判断，如下:

```js
let obj = {
  name: "xxx",
};
console.log("name" in obj); //true
```

##### 7、怎么判断某条属性是否为对象自身属性而非原型属性？

通过 hasOwnProperty

```js
let Fn = function () {
  this.name = "xxxx";
  this.age = "160";
};
Fn.prototype.sex = "girl";
let fn1 = new Fn();
fn1.color = "blue";
console.log(fn1.hasOwnproperty("color")); //true
console.log(fn1.hasOwnproperty("name")); //true
console.log(fn1.hasOwnproperty("sex")); //false
```

##### 8、constructor 与 instanceOf 有何区别?

都可以判断对象类型
都可以判断实列是由某个构造函数创建，instanceOf 判断更加准确一些，constructor 只能判断未被任何修改过的构造函数原型。因为 constructor 是是原型属性，原型被修改了，那它就找不到自己的构造函数了
constructor：是原型对象 property 里面的一个属性，是一个方法，返回创建构造函数的实列
instanceOf：是运算符，返回的是 Boolean 值。

```js
//情况一:原型被修改的构造函数
let Fn = function () {
  this.name = "xxx";
  this.age = "bbb";
};
Fn.prototype = {
  name: "bbb",
  color: "blue",
};
let fn1 = new Fn();
console.log(fn1.constructor === Fn); //false
console.log(fn1 instanceof Fn); //true

//情况二:原型未被修改的构造函数
let Fn2 = function () {
  this.name = "xxx";
  this.age = "bbb";
};

let fn2 = new Fn2();
console.log(fn2.constructor === Fn2); //true
console.log(fn2 instanceof Fn2); //true
```

##### 9、new 的时候做了什么，手动实现 new 方法？

1. 首先创建一个空对像。
2. 建立原型和原型链的关系。
3. 绑定 this 指向构造函数实列。
4. 返回构造函数实列。

```js
//实现new方法的
let Person = function () {
  this.name = "xxx";
  this.age = 28;
};
let newMethod = function (Parent, ...rest) {
  //创建一个对象，以构造函数的原型为基础创建
  let child = Object.create(Parent.Property);
  //绑定this到实列上
  let result = Parent.apply(child, rest);
  //返回当前实列,构造函数没有手动返回值，就返回当前创建的实列。
  return typeof result === "object" ? result : child;
};
Person.Property = {
  sex: "girl",
};
let person1 = newMethod(Person);
console.log(person1.age); //28
console.log(person1.sex); //girl
```

##### 10、能不能创建严格意义上的空对象?

严格意义上的空对象是没有\_\_proto\_\_,只有 null 和 undefined 是没有这个属性的。

```js
//方法一：
let obj = new Object(null);

//方法二
let obj1 = {};
Object.setProperty(obj1, null);
```

#### 递归算法

类似金字塔形，必须有条件终止，典型的求和、阶乘等列子

```js
let sum = (n) => {
  if (n > 0) {
    return sum(n - 1) + n;
  } else {
    return n;
  }
};
```

#### 数组的排序

##### 1、sort 排序

数组内置排序方法，通过系统字符默认排序,直接使用 sort 排序排序不准确，需要调用比较方法，因为 sort 排序是根据首位数字进行排序的，对于两位数字的排序不准确。

```js
//不准确排序
let errSortArr = [4, 1, 5, 56, 2, 12, 34];
errSortArr.sort();
console.log(errSortArr); //[1, 12, 2, 34, 4, 5, 56]

//sort正确排序
let arr = [90, 13, 56, 45, 12, 66];
arr.sort((a, b) => {
  return a - b;
});
console.log(arr); // [12,13,45,56,66,90]

//数组对象sort排序
let objArr = [{ id: 20 }, { id: 12 }, { id: 40 }];
objArr.sort((a, b) => {
  return a.id - b.id;
});
console.log(objArr); //[{id:12},{id:20},{id:40}]
```

##### 2、冒泡排序

原理：就是两个相邻的数据进行两两比较，小的放在前面，大的放在后面，这样一轮下来之后，最小的到了第一位，然后再进行第二轮第三轮的比较.
首先确定比较的轮数，再次确定每次比较的次数。

```js
//冒泡排序
let arr = [90, 13, 56, 45, 12, 66];
//确定循环比较的轮次
for (let i = 0; i < arr.length - 1; i++) {
  //确定循环比较的次数
  for (let j = 0; j < arr.length - 1 - i; j++) {
    let temp = arr[j];
    if (arr[j] > arr[j + 1]) {
      arr[j] = arr[j + 1];
      arr[j + 1] = temp;
    }
  }
}
console.log(arr); //[12, 13, 45, 56, 66, 90]
```

##### 3、选择排序

思路：首先在未排序的数组里面找到最小（大）放在数组的起始位置。
再从剩余元素中继续寻找最小（大）元素，返回放在已排序数组的末尾。

```js
let arr = [90, 13, 56, 45, 12, 66];
for (i = 0; i < arr.length; i++) {
  for (j = i + 1; j < arr.length; j++) {
    let temp = arr[i];
    if (arr[i] > arr[j]) {
      arr[i] = arr[j];
      arr[j] = temp;
    }
  }
}
console.log(arr); //[12, 13, 45, 56, 66, 90]
```

##### 4、插入排序

思路：将数据第一个元素看作一个有序序列，把第二个元素到最后一个元素当作是未排序序列。
从头到尾一次扫描未排序序列，将扫描到的每个元素插入有序序列合适的位置。
如果待插入的元素和有序序列中某个元素相等，则将待插入元素插入到相等元素的后面。

```js
let arr = [90, 13, 56, 45, 12, 66];
for (let i = 1; i < arr.length; i++) {
  for (let j = 0; j < i; j++) {
    if (arr[i] < arr[j]) {
      const temp = arr[i];
      arr[i] = arr[j];
      arr[j] = temp;
    }
  }
}
```

##### 5、快速排序

思路：在已知到数组中取一个基准，将其余的数据以基准为中心，大于放右边，小于放左边。将左右两个子集重复上面的步骤。

```js
let arr = [90, 1, 13, 56, 45, 12, 66];
let quickSortArr = (tempArr) => {
  if (tempArr.length <= 1) {
    return tempArr;
  }
  let pivotIndex = Math.floor(tempArr.length / 2);
  let pivot = tempArr.splice(pivotIndex, 1);
  let leftArr = [];
  let rightArr = [];
  for (let i = 0; i < tempArr.length; i++) {
    if (tempArr[i] < pivot) {
      leftArr.push(tempArr[i]);
    } else {
      rightArr.push(tempArr[i]);
    }
  }
  return quickSortArr(leftArr).concat(pivot, quickSortArr(rightArr));
};

let newArr = quickSortArr(arr);
console.log(newArr); //[1, 12, 13, 45, 56, 66, 90]
```

##### 6.堆排序

概念：就是完全二叉树，分为大顶堆和小顶堆
大顶堆：每个节点的值都大于或者等于它的左右子节点值。
小顶堆：每个节点的值都小于或者等于它的左右孩子点值。

公式：
a、每个元素 arr[i]的左右孩子节点分别是 arr[i*2+1]、arr[i*2+2];
b、要找到最后一个不是叶子结点的结点为（arr.length/2-1）往下取整。

实现思路：  
1、首先要实现堆结构，大顶堆，那么整个序列的最大值就是堆顶的根结点。
2、将堆顶元素和最后一个元素进行互换，那么末尾元素就存入了最大值。
3、将剩余的 n-1 个元素重新构建成一个大顶堆，重复上面的操作。
参考地址：
https://blog.csdn.net/qq_48315043/article/details/121405814
https://blog.csdn.net/weixin_46726346/article/details/112974224

```js
let arr = [90, 13, 56, 45, 12, 66];
//数组元素互换
function swap(arr, i, j) {
  let temp = arr[i];
  arr[i] = arr[j];
  arr[j] = temp;
}
//实现堆结构
function adHeap(i, arr, length) {
  let temp = arr[i];
  for (k = i * 2 + 1; k < length; k = k * 2 + 1) {
    if (k + 1 < length && arr[k] < arr[k + 1]) {
      k++;
    }
    if (arr[k] > temp) {
      arr[i] = arr[k];
      i = k;
    } else {
      break;
    }
  }
  arr[i] = temp;
  return arr;
}

//实现堆排序
function heapSort(arr) {
  let result = [];
  for (let i = parseInt(arr.length / 2) - 1; i >= 0; i--) {
    adHeap(i, arr, arr.length);
  }
  for (let j = arr.length - 1; j > 0; j--) {
    swap(arr, 0, j);
    result = adHeap(0, arr, j);
  }
  return result;
}
let newArr = heapSort(arr);
console.log(newArr);
```

##### 7、归并排序

#### 深浅拷贝

深拷贝：是复制另外一个空间，两个不会受到影响。
浅拷贝：是拷贝一个地址链接，任何一个变化都会影响到另外一个的变化。
解构赋值：一维数组是深拷贝，二维和多维是浅拷贝。
日常工作中如何深拷贝的？
json.parset(json.String(obj));
副作用：对于一些特殊的，处理会出错，比如 function 等
如何解决？ 1.自己写一个深拷贝函数。 2.通过工具函数，lodash

```js
//手写深拷贝
/**
 * 思路：
 * 1、null和基础类型(number,boolean,string)直接返回
 * 2、array和可以for in的对象，通过for in递归拷贝
 * 3、处理function,Map,Set
 * 4、处理正则表达式
 * 参考地址:https://www.cnblogs.com/echolun/p/16157161.html
 *
 **/
//是否是对象
let isObject = (data, map = new Map()) => {
  const type = typeof data;
  return data !== null && (type === "object" || type === "function");
};

//判断对象类型
let getObjectType = (obj) => {
  return Object.prototype.toString.call(obj);
};

//克隆正则
let cloneRegExp = (obj) => {
  const { source, flags, lastIndex } = obj;
  let obj_ = new RegExp(source, flags);
  obj_.lastIndex = lastIndex;
  return obj_;
};
//克隆其他
let cloneOtherObject = (obj, type) => {
  const basicTypes = [
    "[object Boolean]",
    "[object Number]",
    "[object String]",
    "[object Date]",
  ];
  if (basicTypes.includes(type)) {
    return new obj.constructor(obj.valueOf());
  }
  if (type === "[object Symbol]") {
    return Object(obj.valueOf);
  }
  if (type === "[object RegExp]") {
    return cloneRegExp(obj);
  }
  if (type === "[object Function]") {
    return obj;
  }
};
//深拷贝
let deepClone = (data, map = new Map()) => {
  if (!isObject(data)) {
    return data;
  }
  let obj;
  const objType = getObjectType(data);
  const ergodicTypes = [
    "[object Array]",
    "[object Object]",
    "[object Set]",
    "[object Map]",
  ];
  if (ergodicTypes.includes(objType)) {
    obj = new data.constructor();
  } else {
    return cloneOtherObject(data, objType);
  }
  //处理循环引用问题，防止栈溢出
  if (map.has(data)) {
    return map.get(data);
  }
  map.set(data, obj);
  //拷贝Set
  if (objType === "[object Set]") {
    obj.forEach((val, key) => {
      obj.add(key, deepClone(val));
    });
    return obj;
  }
  //拷贝Map
  if (objType === "[object Map]") {
    obj.forEach((val, key) => {
      obj.set(key, deepClone(val));
    });
    return obj;
  }
  //拷贝数组和{}
  for (let key in data) {
    obj[key] = deepClone(data[key], map);
  }
  return obj;
};
let obj = {
  name: "听风",
  age: 29,
  other: {
    gender: "male",
    arr: [1, 2, 3],
  },
};
deepClone(obj);
```

#### this 指向

1. 谁调用指向谁，多层调用的时候只看它的直接上级。
2. 箭头函数没有 this，他的 this 指向它定义位置的上下文，箭头函数不会创建自己的执行上下文，而是将 this 指向外部函数已经创建的执行上下文。

<b>函数调用的几种方法:</b>
直接调用，对象方法调用，间接调用，bind,apply,call 绑定调用，构造函数调用，不同的函数调用，this 的指向不一样。
直接调用，this 指向的是 window,方法调用，指向的是它调用的那个对象，构造函数 this 指向的是构造函数的实列。

#### 跨域解决

#### 性能优化

地址栏输入 url 到服务端接收到 http 的请求，再到服务将数据返回给客户端，客户端再将数据渲染到浏览，这个过程中做优化，那前端需要考虑的点就是，更快的网络通信，和更高效的数据处理。
从这两个方便出发：
更快的网络通信：

1. 服务通信层：减少 http 的请求，请求需要建立连接，DNS 解析优化，预解析，CDN 负载均衡和缓存
2. 数据传输层：

- a、缓存:浏览器的缓存机制，强缓存和协商缓存。
- b、压缩:数据压缩：开启 gzip。代码文件压缩：html,css,js 合并压缩。静态资源压缩：jpeg,去除元数据，图标，图片等压缩。头与报文：http1.1 臃肿的头部，减少数据的携带和 cookie 的传输。

3. 通信协议本身：http1.0 升级到 2.0，优势：二进制解析比字符串的解析好分割，而且好携带，解析快。头部的压缩，没有臃肿的头部携带，传输会更快。链路复用，减少了 http 的连接，在有限的请求里面可以处理更多的数据。

更高效的数据处理：

1. 通过工具分析，谷歌自带的 highoust，主要是对网站进行一个总体评分，但是还细分每个点需要优化的细节，根据细节的分析，去一个一个的优化处理，再进行前后数据对比，得出性能优化的数据。
2. 代码本身：减少 dom 元素的层级嵌套，能用 cs 的不要用 js，减少页面的重排，能用全局 css 不要用 scope，对于不常用的对象通过 object.frez 冻结，释放内存，减少作用域的查找，少用闭包等。

#### git 冲突如何解决？

#### 数组/对象的遍历

##### 1. 如何遍历数组/对象？

for 循环可以遍历数组和对象
数组的遍历：map,each,filter,for of，for 循环，reduce 等。
对象:for in,for 循环

##### 2. for in 遍历对象时会不会访问原型？

for in 遍历对象的时候是会访问原型的

##### 3. 如何判断是不是原型属性？

通过 Object.hasOwnProperty 判断对象属性是自己的而非原型上的。再结合 in 可以查找对象和原型上的属性。

```js
//判断是否原型上的属性
let isProtoAttr = function (obj, attr) {
  return !obj.hasOwnProperty(attr) && attr in obj;
};
```

#### 事件循环机制

js 是单线程程序，事件循环是 js 的执行机制。所有的同步任务都是在主线上执行，主线程还有一个队列，宏任务和微任务是放在队列里面，等待执行，当主线程任务全部执行完之后，就会去执行队列里面的任务，微任务永远在宏任务执行之前。宏任务下一个事件执行的开始，每次执行一个宏任务之后就会进行下一轮的事件执行机制，一直这么执行下去，直到任务清空。

##### 1. 如何循环

第一次进入整体代码 script（宏任务，开始第一次循环，接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。

##### 2. js 的执行机制

同步任务（主线程）整体代码 script（宏任务） => 微任务 => 下一个宏任务 => 循环下去。

##### 3. js 事件

广义上的同步和异步，更细致的又分宏任务和微任务
宏任务：整体代码 script,setTimeOut,setInterval.
微任务：promise,nextTick.

#### 地址栏输入 url 地址到整个网页加载完成经历了怎样的过程?

1. 浏览器接收到 URL 地址，到网络线程的开启（开启网络线程请求对方的服务器），线程的开启实现是在浏览器内部完成的，接到地址后对地址进行分析，https 什么样的传输协议，域名是什么，服务商是谁。
2. 一个完整的 http 请求的发出。（请求对方服务器需要建立 http 请求）这个阶段主要分两部分，DNS 解析和通信线路的建立。首先对 DNS 的一个解析，将域名解析成服务器的 ip 地址，明确访问的是哪个服务器，其次建立通信线路，也就是 TCP 握手连接。
3. 服务器接到请求转到具体的数据处理后台进行处理，（前端一般不需要考虑）
4. 前后的 http 请求交互和缓存机制，建立 TCP 连接之后，就可以进行通信，这个时候往往会加一些反向代理 CDN 缓存和负载均衡等，还有浏览器的缓存机制设置。
5. 浏览器接到数据包后渲染路径：首先 HTML 创建 dom tree ,css 创建，样式结构体，然后 dom tree 和样式结构体形成 render tree,计算位置和大小 UI 引擎来绘制页面。
6. js 引擎的解析过程。

#### js 引擎解析过程

js 引擎主要就是 V8 引擎执行代码的流程，V8 引擎做的事情就是把 js 代码解析成 010101 等这样的字节码，它的渲染流程就是：
js 代码 => 被解析成 AST（抽象语法树）=> 然后再转换成字节码(byteCode)，特性是跨平台的，在 window 可以运行，mac 也能运行 => 优化的机器码（机器码的运行效率更高）

#### 怎么打断点

打断点主要是通过 Debugger 去打断点，谷歌开发者工具和 vscode 提供了多种 debugger 打断点的方式。

1. 普通断点：Chrome 的 DevTools 选项卡 sources 面板，对你需要断点的文件进行调试。
2. 条件断点：在断点这一行右击，选择 editor breakpoint 然后添加条件语句只有为 true 的时候才会执行。
3. Dom 断点：在 Chrome 的 DevTools 的 Element 面板的对应元素上右击，选择 Break on
4. url 断点：在 Chrome 的 Devtools 的 source 面板，可以添加 XHR 的 url 断点，当 ajax 请求对应的 url 的时候就会断住，可以用来调试请求相关的代码。
5. Event Listener 断点：在 Chrome Devtools 的 Sources 面板还可以添加 Event Listener 的断点，指定当发生什么事件时断住，可以用来调试事件相关代码。
6. 异常断点：在 VSCode 的 Debugger 面板勾选 Uncaught Exceptions 和 Caught Exceptions 可以添加异常断点，在抛出异常未被捕获或者被捕获时断柱。用来调试一些发生异常的代码时很有用。

#### 缓存

前端缓存主要是分 http 缓存和浏览器缓存。

##### 1. http 缓存

http 缓存 就是 http 请求传输时用到的缓存，主要是在服务器上设置，http 缓存是从第二次请求开始的，分为强缓存和协商缓存。

- <b>流程:</b> http 第一次请求资源的时候，服务器返回资源并在 response 的 header 中回传资源的缓存参数，第二次请求的时候浏览器判断这些请求参数，击中强缓存就直接使用缓存内容，否则就把请求参数加到 request header 头中传给服务器，看是否击中协商缓存，击中则使用该缓存资源，否则服务器会返回新的资源。

- <b>强缓存:</b>
  浏览器直接读取缓存，不需要发送任何请求到服务器，特点就是速度很快。
  强缓存的 respone header 参数有两种：

  1. Cacel-Control:max-age=3600;
     表示在浏览器会缓存 3600 秒，就是指一个小时，在这一个小时内多次请求的话浏览器不会发新的请求，直接读取缓存。
     Cacel-Control 的值有: max-age，max-state，min-fresh。
     假设所请求资源于 4 月 5 日缓存, 且在 4 月 12 日过期.当 max-age 与 max-stale 和 min-fresh 同时使用时, 它们的设置相互之间独立生效, 最为保守的缓存策略总是有效. 这意味着, 如果 max-age=10 days, max-stale=2 days, min-fresh=3 days, 那么:

     - max-age:表示缓存于多久失效,覆盖原缓存周期, 缓存资源将在 4 月 15 日失效(5+10=15);
     - max-state:表示缓存失效后两天有效,缓存资源将在 4 月 14 日失效(12+2=14),状态码是 110;
     - min-fresh:表示要留有多久的新鲜期，缓存资源将在 4 月 9 日失效(12-3=9);

  2. Expires: Thu, 25 May 2020 12:30:00 GMT;
     代表该资源在 2020 年 5 月 25 日 12 点 30 分（格林威治时间）失效。
     Expires 有一个很大的弊端，它返回的是服务的时间，但是判断是根据客户端的时间去判断的。如何客户改变客户端的时候，或者因为时区差，服务器的时间和客户端的时间不一致，就会导致判断出错，缓存失效。

- <b>协商缓存:</b>
  协商缓存就是强缓存失效后， 浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识判断内容是否有更新，没有更新直接读取缓存资源（状态码是 304），有更新服务器会返回新的内容和缓存标识，重新存入缓存。
  协商缓存的参数:
  1. respones header 参数 ETag:服务器通过自定义计算对资源生成一个唯一标识，然后浏览器第一次请求某个 URL 地址的时候， 会把这个参数放到响应头（respones header）传到浏览器，浏览器会把这个 ETag 值存起来。
  2. request header 参数 If-None-Match:浏览器再次发送请求的时候，会在请求头上加上 If-None-Match,它的值就是 ETage 的值，用来发送给服务器验证资源的内容有没有被修改，如果有资源的 ETage 相匹配，那么就返回 304 状态码，浏览器就会从缓存中获取资源。
  3. Last-Modified：当 Response Header 中没有 ETag，Cache-Control，Expires，Pragma 这类缓存相关字段，只有 Last-Modified，浏览器也会缓存，理论上，应该会在下一次请求中带上 If-Modified-Since 的请求头，去服务端验证资源是否过期，过期就响应码就为 200 并返回相应的资源，没过期响应码就是 304，浏览器会从缓存中获取资源。
     但实际上，各个浏览器对这部分的实现不太相同。

##### 2. 浏览器缓存

浏览器缓存：本地数据存储，cookie,webSql,localstorage,sessionStorage，indexDB 等

#### xss 攻击和 csrf 攻击的区别

任何可输入的地方都可能成为 xss 的攻击，包括 URL 地址

-
