(window.webpackJsonp=window.webpackJsonp||[]).push([[115],{466:function(t,s,i){"use strict";i.r(s);var a=i(13),v=Object(a.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"this"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#this"}},[t._v("#")]),t._v(" this")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("执行上下文")]),t._v(" "),s("p",[t._v("this 的指向，是在调用函数时根据执行上下文所动态确定的。")])]),t._v(" "),s("p",[t._v("如果构造函数中显式返回一个值，且返回的是一个对象，那么 this 就指向这个返回的对象；如果返回的不是一个对象，那么 this 仍然指向实例。")]),t._v(" "),s("p",[t._v("函数具有 length 属性，表示形参的个数。")]),t._v(" "),s("h3",{attrs:{id:"总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),s("ol",[s("li",[t._v("谁调用指向谁，多层调用的时候只看它的直接上级。")]),t._v(" "),s("li",[t._v("箭头函数没有 this，他的 this 指向它定义位置的上下文，箭头函数不会创建自己的执行上下文，而是将 this 指向外部函数已经创建的执行上下文。")])]),t._v(" "),s("h3",{attrs:{id:"函数调用方式不同-this-的指向。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#函数调用方式不同-this-的指向。"}},[t._v("#")]),t._v(" 函数调用方式不同,this 的指向。")]),t._v(" "),s("ol",[s("li",[t._v("普通函数的调用，this 指向的是 window")]),t._v(" "),s("li",[t._v("对象方法的调用，this 指的是该对象，且是最近的对象")]),t._v(" "),s("li",[t._v("构造函数的调用，this 指的是实例化的新对象")]),t._v(" "),s("li",[t._v("apply 和 call 调用，this 指向参数中的对象")]),t._v(" "),s("li",[t._v("匿名函数的调用，this 指向的是全局对象 window")]),t._v(" "),s("li",[t._v("定时器中的调用，this 指向的是全局变量 window")])])])}),[],!1,null,null,null);s.default=v.exports}}]);